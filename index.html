<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Plexiglass Music Panes – Mobile Enabled</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
      position: relative;
      z-index: 100;
    }
    /* No instruction text displayed */
    .hue-slider {
      position: absolute;
      z-index: 200;
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      background: #ddd;
      outline: none;
      border-radius: 4px;
    }
    .hue-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #fff;
      border: 2px solid #444;
      border-radius: 50%;
      cursor: pointer;
    }
    .hue-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #fff;
      border: 2px solid #444;
      border-radius: 50%;
      cursor: pointer;
    }
    #freqInput {
      position: absolute;
      z-index: 300;
      font-size: 18px;
      padding: 3px;
      border: 2px solid #444;
      border-radius: 4px;
      text-align: center;
      width: 90px;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <input type="text" id="freqInput">
  <script>
    // -------- Frequency Mapping --------
    function getFrequencyFromL(L) {
      return 200 + (L / 100) * 800;
    }
    // -------- Mapping Presets (Original Vibrant) --------
    const mappingPresets = [
      { L_low: 20, L_high: 80, H_low: 240, H_high: 60 },   // Blue → Yellow
      { L_low: 20, L_high: 80, H_low: 0,   H_high: 60 },    // Red → Yellow
      { L_low: 15, L_high: 75, H_low: 270, H_high: 30 },    // Purple → Orange
      { L_low: 25, L_high: 85, H_low: 120, H_high: 60 }     // Green → Yellow
    ];
    function randomMapping() {
      return mappingPresets[Math.floor(Math.random() * mappingPresets.length)];
    }
    const sliderRange = 800; // Slider: 0–800, step 0.1

    // -------- Canvas & Audio Setup --------
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      updateCellDimensions();
    });
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    // -------- Color Helper --------
    function hslToCSS(hsl) {
      return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
    }

    // -------- Global Variables --------
    let panes = [];
    let selectedPane = null;
    let isDragging = false;
    let dragOffsetX = 0, dragOffsetY = 0;
    let resizing = false;
    let resizeOffsetX = 0, resizeOffsetY = 0;
    const resizeMargin = 10;
    let paneIdCounter = 0;

    // -------- Pane Class --------
    function Pane(x, y, width, height, mapping, sliderValue) {
      this.id = paneIdCounter++;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.mapping = mapping;
      let L = mapping.L_low + (sliderValue / sliderRange) * (mapping.L_high - mapping.L_low);
      let H = mapping.H_low + (sliderValue / sliderRange) * (mapping.H_high - mapping.H_low);
      this.hsl = { h: H, s: 100, l: L };
      this.alpha = 0.95;
      this.baseFrequency = getFrequencyFromL(L);
      this.oscillator = audioCtx.createOscillator();
      this.gainNode = audioCtx.createGain();
      this.oscillator.type = 'sine';
      this.oscillator.frequency.value = this.baseFrequency;
      this.gainNode.gain.value = 0.05;
      this.oscillator.connect(this.gainNode);
      this.gainNode.connect(audioCtx.destination);
      this.oscillator.start();
      this.slider = null;
    }
    Pane.prototype.draw = function(ctx, visibleArea) {
      // Draw the pane as a piece of plexiglass
      ctx.fillStyle = hslToCSS(this.hsl);
      ctx.globalAlpha = this.alpha;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.strokeStyle = "rgba(0,0,0,0.8)";
      ctx.lineWidth = 2;
      ctx.strokeRect(this.x, this.y, this.width, this.height);
      if (visibleArea > 0.001) {
        ctx.fillStyle = "black";
        ctx.font = "20px Georgia, serif";
        let freq = this.oscillator.frequency.value;
        ctx.fillText(freq.toFixed(2) + " Hz", this.x + 8, this.y + 28);
      }
    };
    Pane.prototype.contains = function(x, y) {
      return x >= this.x && x <= this.x + this.width &&
             y >= this.y && y <= this.y + this.height;
    };

    // -------- Create Initial Panes --------
    function initPanes() {
      function randomRange(min, max) { return min + Math.random() * (max - min); }
      for (let i = 0; i < 3; i++) {
        let width = randomRange(120, 300);
        let height = randomRange(120, 300);
        let x = randomRange(0, canvas.width - width);
        let y = randomRange(0, canvas.height - height);
        let mapping = randomMapping();
        let sliderValue = Math.random() * sliderRange;
        panes.push(new Pane(x, y, width, height, mapping, sliderValue));
      }
    }
    initPanes();

    // -------- Frequency Input for Editing & Tab Navigation --------
    const freqInput = document.getElementById('freqInput');
    let editingPane = null;
    function startEditing(pane) {
      editingPane = pane;
      freqInput.value = pane.oscillator.frequency.value.toFixed(2);
      freqInput.style.display = 'block';
      freqInput.style.left = (pane.x + 8) + "px";
      freqInput.style.top = (pane.y + 8) + "px";
      freqInput.focus();
      freqInput.select();
    }
    function commitEditing() {
      if (editingPane) {
        let newFreq = parseFloat(freqInput.value);
        if (!isNaN(newFreq)) {
          let newL = ((newFreq - 200) / 800) * 100;
          newL = Math.max(editingPane.mapping.L_low, Math.min(newL, editingPane.mapping.L_high));
          let ratio = (newL - editingPane.mapping.L_low) / (editingPane.mapping.L_high - editingPane.mapping.L_low);
          let newH = editingPane.mapping.H_low + ratio * (editingPane.mapping.H_high - editingPane.mapping.H_low);
          editingPane.hsl.l = newL;
          editingPane.hsl.h = newH;
          editingPane.baseFrequency = getFrequencyFromL(newL);
          if (editingPane.slider) {
            let xVal = ((editingPane.hsl.l - editingPane.mapping.L_low) / (editingPane.mapping.L_high - editingPane.mapping.L_low)) * sliderRange;
            editingPane.slider.value = xVal;
          }
        }
        freqInput.style.display = 'none';
        editingPane = null;
      }
    }
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && editingPane) {
        commitEditing();
      } else if (e.key === 'Tab') {
        e.preventDefault();
        let sorted = panes.slice().sort((a, b) => a.id - b.id);
        if (!editingPane && sorted.length > 0) {
          startEditing(sorted[0]);
        } else if (editingPane) {
          let idx = sorted.findIndex(p => p.id === editingPane.id);
          commitEditing();
          idx = e.shiftKey ? (idx - 1 + sorted.length) % sorted.length : (idx + 1) % sorted.length;
          startEditing(sorted[idx]);
        }
      }
    });
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      for (let i = panes.length - 1; i >= 0; i--) {
        let pane = panes[i];
        if (mouseX >= pane.x + 8 && mouseX <= pane.x + 108 &&
            mouseY >= pane.y + 8 && mouseY <= pane.y + 35) {
          startEditing(pane);
          break;
        }
      }
    });

    // -------- Mouse Events for Drag/Resize (for desktop) --------
    canvas.addEventListener('mousedown', (e) => {
      if (audioCtx.state === 'suspended') { audioCtx.resume(); }
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      for (let i = panes.length - 1; i >= 0; i--) {
        let pane = panes[i];
        if (pane.contains(mouseX, mouseY)) {
          if (mouseX >= pane.x + pane.width - resizeMargin &&
              mouseY >= pane.y + pane.height - resizeMargin) {
            selectedPane = pane;
            resizing = true;
            resizeOffsetX = (pane.x + pane.width) - mouseX;
            resizeOffsetY = (pane.y + pane.height) - mouseY;
          } else {
            selectedPane = pane;
            isDragging = true;
            dragOffsetX = mouseX - pane.x;
            dragOffsetY = mouseY - pane.y;
          }
          panes.splice(i, 1);
          panes.push(pane);
          return;
        }
      }
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!selectedPane) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      if (resizing) {
        let newWidth = mouseX - selectedPane.x + resizeOffsetX;
        let newHeight = mouseY - selectedPane.y + resizeOffsetY;
        selectedPane.width = Math.max(50, newWidth);
        selectedPane.height = Math.max(50, newHeight);
      } else if (isDragging) {
        selectedPane.x = mouseX - dragOffsetX;
        selectedPane.y = mouseY - dragOffsetY;
      }
    });
    canvas.addEventListener('mouseup', () => {
      selectedPane = null;
      isDragging = false;
      resizing = false;
    });

    // -------- Mobile Touch Events --------
    let lastTapTime = 0;
    let tapTimeout;
    let longPressTimeout;
    const longPressDuration = 800; // ms

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mouseX = touch.clientX - rect.left;
      const mouseY = touch.clientY - rect.top;
      
      // Start long-press detection:
      longPressTimeout = setTimeout(() => {
        // Long press: if a pane is touched, prompt deletion.
        for (let i = panes.length - 1; i >= 0; i--) {
          let pane = panes[i];
          if (pane.contains(mouseX, mouseY)) {
            if (confirm("Delete pane?")) {
              if (pane.slider) { document.body.removeChild(pane.slider); }
              pane.oscillator.stop();
              pane.oscillator.disconnect();
              pane.gainNode.disconnect();
              panes.splice(i, 1);
            }
            break;
          }
        }
      }, longPressDuration);
      
      // Check if touch is on a pane.
      let found = false;
      for (let i = panes.length - 1; i >= 0; i--) {
        let pane = panes[i];
        if (pane.contains(mouseX, mouseY)) {
          found = true;
          const currentTime = new Date().getTime();
          if (currentTime - lastTapTime < 300) {
            // Double-tap detected.
            clearTimeout(tapTimeout);
            clearTimeout(longPressTimeout);
            toggleHueSlider(pane);
          } else {
            // Not a double-tap: decide if this is a drag or resize.
            if (mouseX >= pane.x + pane.width - resizeMargin &&
                mouseY >= pane.y + pane.height - resizeMargin) {
              selectedPane = pane;
              resizing = true;
              resizeOffsetX = (pane.x + pane.width) - mouseX;
              resizeOffsetY = (pane.y + pane.height) - mouseY;
            } else {
              selectedPane = pane;
              isDragging = true;
              dragOffsetX = mouseX - pane.x;
              dragOffsetY = mouseY - pane.y;
            }
          }
          panes.splice(i, 1);
          panes.push(pane);
          break;
        }
      }
      if (!found) {
        // Touch on empty space.
        const currentTime = new Date().getTime();
        if (currentTime - lastTapTime < 300) {
          clearTimeout(tapTimeout);
          // Double-tap on empty space creates a new pane.
          let mapping = randomMapping();
          let sliderValue = Math.random() * sliderRange;
          let width = 200, height = 200;
          let x = mouseX - width / 2;
          let y = mouseY - height / 2;
          panes.push(new Pane(x, y, width, height, mapping, sliderValue));
        } else {
          tapTimeout = setTimeout(() => {
            // Single tap on empty space: do nothing.
          }, 300);
        }
      }
      lastTapTime = new Date().getTime();
    }, { passive: false });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      clearTimeout(longPressTimeout);
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mouseX = touch.clientX - rect.left;
      const mouseY = touch.clientY - rect.top;
      if (selectedPane) {
        if (resizing) {
          let newWidth = mouseX - selectedPane.x + resizeOffsetX;
          let newHeight = mouseY - selectedPane.y + resizeOffsetY;
          selectedPane.width = Math.max(50, newWidth);
          selectedPane.height = Math.max(50, newHeight);
        } else if (isDragging) {
          selectedPane.x = mouseX - dragOffsetX;
          selectedPane.y = mouseY - dragOffsetY;
        }
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      clearTimeout(longPressTimeout);
      selectedPane = null;
      isDragging = false;
      resizing = false;
    }, { passive: false });

    // -------- Composite Sound Calculation via Sampling --------
    const sampleCountX = 50, sampleCountY = 50;
    let cellWidth, cellHeight, cellArea;
    function updateCellDimensions() {
      cellWidth = canvas.width / sampleCountX;
      cellHeight = canvas.height / sampleCountY;
      cellArea = cellWidth * cellHeight;
    }
    updateCellDimensions();
    window.addEventListener('resize', updateCellDimensions);

    // compositeRegions: key -> { area, sumX, sumY, sumL, sumH, count }
    let compositeRegions = {};
    // compositeOscillators: key -> { osc, gain }
    let compositeOscillators = {};

    // -------- Animation & Audio Update --------
    // Using "overlay" blend mode for a plexiglass effect.
    function animate() {
      requestAnimationFrame(animate);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'screen';
      const currentTime = audioCtx.currentTime;
      
      compositeRegions = {};
      let individualVolumes = {};
      panes.forEach(p => { individualVolumes[p.id] = 0; });
      
      for (let i = 0; i < sampleCountX; i++) {
        for (let j = 0; j < sampleCountY; j++) {
          let sampleX = (i + 0.5) * cellWidth;
          let sampleY = (j + 0.5) * cellHeight;
          let covering = [];
          for (let pane of panes) {
            if (sampleX >= pane.x && sampleX <= pane.x + pane.width &&
                sampleY >= pane.y && sampleY <= pane.y + pane.height) {
              covering.push(pane);
            }
          }
          if (covering.length === 1) {
            individualVolumes[covering[0].id] += cellArea;
          } else if (covering.length >= 2) {
            let ids = covering.map(p => p.id).sort((a, b) => a - b);
            let key = ids.join(",");
            if (!compositeRegions[key]) {
              compositeRegions[key] = { area: 0, sumX: 0, sumY: 0, sumL: 0, sumH: 0, count: 0 };
            }
            compositeRegions[key].area += cellArea;
            compositeRegions[key].sumX += sampleX * cellArea;
            compositeRegions[key].sumY += sampleY * cellArea;
            covering.forEach(p => {
              compositeRegions[key].sumL += p.hsl.l;
              compositeRegions[key].sumH += p.hsl.h;
            });
            compositeRegions[key].count += covering.length;
          }
        }
      }
      const referenceArea = 30000;
      
      panes.forEach(pane => {
        let vol = 0.05 * (individualVolumes[pane.id] / referenceArea);
        vol = Math.min(vol, 0.2);
        pane.gainNode.gain.setTargetAtTime(vol, currentTime, 0.05);
        pane.oscillator.frequency.setTargetAtTime(pane.baseFrequency, currentTime, 0.05);
        pane.draw(ctx, individualVolumes[pane.id]);
        if (pane.slider) {
          pane.slider.style.left = pane.x + "px";
          pane.slider.style.top = (pane.y + pane.height + 5) + "px";
          pane.slider.style.width = pane.width + "px";
        }
      });
      
      for (let key in compositeRegions) {
        let region = compositeRegions[key];
        let area = region.area;
        let avgL = region.sumL / region.count;
        let avgH = region.sumH / region.count;
        let compFreq = getFrequencyFromL(avgL);
        let compVol = 0.05 * (area / referenceArea);
        compVol = Math.min(compVol, 0.2);
        if (!compositeOscillators[key]) {
          let osc = audioCtx.createOscillator();
          let gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.value = compFreq;
          gain.gain.value = compVol;
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          compositeOscillators[key] = { osc, gain };
        } else {
          let comp = compositeOscillators[key];
          comp.osc.frequency.setTargetAtTime(compFreq, currentTime, 0.05);
          comp.gain.gain.setTargetAtTime(compVol, currentTime, 0.05);
        }
        let centroidX = region.sumX / area;
        let centroidY = region.sumY / area;
        let compColor = { h: avgH, s: 100, l: avgL };
        ctx.fillStyle = hslToCSS(compColor);
        ctx.font = "20px Georgia, serif";
        ctx.fillText(compFreq.toFixed(2) + " Hz", centroidX - 30, centroidY);
      }
      for (let key in compositeOscillators) {
        if (!(key in compositeRegions)) {
          compositeOscillators[key].osc.stop();
          compositeOscillators[key].osc.disconnect();
          compositeOscillators[key].gain.disconnect();
          delete compositeOscillators[key];
        }
      }
    }
    animate();
  </script>
</body>
</html>
